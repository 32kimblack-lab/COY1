rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Helper function to check if user is collection owner or admin
    function isCollectionOwnerOrAdmin(collectionData) {
      return isAuthenticated() && 
        (request.auth.uid == collectionData.ownerId || 
         request.auth.uid in collectionData.get('owners', []));
    }
    
    // Users collection
    match /users/{userId} {
      // Users can read their own data
      allow read: if isOwner(userId);
      // Users can write their own data (including updating followedCollectionIds)
      allow write: if isOwner(userId);
      // Users can delete their own account
      allow delete: if isOwner(userId);
      // Allow read for other users (for profiles, search, etc.)
      allow read: if isAuthenticated();
      
      // Allow users to update friends array when accepting/denying friend requests or unadding
      // This allows updating another user's friends array when accepting/denying their request or unadding
      // Also allow updating blockedByUsers array when blocking/unblocking
      // Also allow updating collections array (for leaving collections)
      // Also allow removing user from friends array during account deletion
      allow update: if isAuthenticated() && (
        isOwner(userId) ||
        // Allow updating friends array only (for friend request acceptance/denial or unadd)
        // Check that only friends array changed and current user is being added or removed
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['friends']) &&
         (((request.auth.uid in request.resource.data.get('friends', [])) &&
           !(request.auth.uid in resource.data.get('friends', []))) ||
          (!(request.auth.uid in request.resource.data.get('friends', [])) &&
           (request.auth.uid in resource.data.get('friends', []))))) ||
        // Allow updating blockedByUsers array only (for blocking/unblocking)
        // Check that only blockedByUsers array changed and current user is being added or removed
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['blockedByUsers']) &&
         (((request.auth.uid in request.resource.data.get('blockedByUsers', [])) &&
           !(request.auth.uid in resource.data.get('blockedByUsers', []))) ||
          (!(request.auth.uid in request.resource.data.get('blockedByUsers', [])) &&
           (request.auth.uid in resource.data.get('blockedByUsers', []))))) ||
        // Allow updating collections array only (for leaving collections)
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['collections'])) ||
        // Allow removing a user from friends array during account deletion
        // When deleting account, user can remove themselves from other users' friends list
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['friends']) &&
         !(request.auth.uid in request.resource.data.get('friends', [])) &&
         (request.auth.uid in resource.data.get('friends', [])))
      );
      
      // IMPORTANT: Allow username queries for login (even when not authenticated)
      // This is needed because users need to find their email by username before they can authenticate
      allow list: if request.query != null && 
                     request.query.where != null &&
                     request.query.where[0].field == 'username';
      
      // Deleted collections subcollection
      match /deleted_collections/{collectionId} {
        allow read, write: if isOwner(userId);
      }
      
      // Notifications subcollection
      match /notifications/{notificationId} {
        // Users can read their own notifications
        allow read: if isOwner(userId);
        // Anyone authenticated can create notifications (for sending notifications to other users)
        allow create: if isAuthenticated();
        // Users can update/delete their own notifications
        allow update, delete: if isOwner(userId);
      }
    }
    
    // Collections collection
    match /collections/{collectionId} {
      // Anyone authenticated can read collections
      allow read: if isAuthenticated();
      
      // Only owner can create collections
      allow create: if isAuthenticated() && request.resource.data.ownerId == request.auth.uid;
      
      // Update rules: Allow multiple scenarios
      allow update: if isAuthenticated() && (
        // Scenario 1: Owner or admin can update anything
        isCollectionOwnerOrAdmin(resource.data) ||
        // Scenario 2: User can update followers array (for follow/unfollow)
        // Check if only followers and followerCount changed, and user is adding/removing themselves
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followers', 'followerCount']) &&
         ((request.auth.uid in request.resource.data.get('followers', [])) != 
          (request.auth.uid in resource.data.get('followers', [])))) ||
        // Scenario 3: User can add themselves to members (for join)
        // Check if only members, memberCount, and pendingJoins changed, and user is adding themselves
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members', 'memberCount', 'pendingJoins']) &&
         !(request.auth.uid in resource.data.get('members', [])) &&
         (request.auth.uid in request.resource.data.get('members', []))) ||
        // Scenario 4: User can remove themselves from members (for leave or account deletion)
        // Check if only members, memberCount, memberJoinDates, and owners changed, and user is removing themselves
        // Also allow removing from owners if they were an admin
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members', 'memberCount', 'memberJoinDates', 'owners']) &&
         (request.auth.uid in resource.data.get('members', [])) &&
         !(request.auth.uid in request.resource.data.get('members', [])) &&
         request.auth.uid != resource.data.ownerId) ||
        // Scenario 4b: Allow removing user from members during account deletion
        // When deleting account, user can remove themselves from any collection
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members', 'memberCount']) &&
         (request.auth.uid in resource.data.get('members', [])) &&
         !(request.auth.uid in request.resource.data.get('members', []))) ||
        // Scenario 5: Allow updating members array when joining (includes invitedUsers removal)
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members', 'memberCount', 'pendingJoins', 'invitedUsers']) &&
         (request.auth.uid in request.resource.data.get('members', []) || 
          request.auth.uid == resource.data.ownerId ||
          request.auth.uid in resource.data.get('owners', [])))
      );
      
      // Only owner can delete
      allow delete: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
    }
    
    // Posts collection
    match /posts/{postId} {
      // Anyone authenticated can read posts
      allow read: if isAuthenticated();
      // Only author can create posts
      allow create: if isAuthenticated() && request.resource.data.authorId == request.auth.uid;
      // Only author can update their posts (for edit post - caption, taggedUsers, allowDownload, allowReplies)
      allow update: if isAuthenticated() && resource.data.authorId == request.auth.uid;
      // Author or collection owner can delete posts
      // Also allow author to delete their posts even in other people's collections (for account deletion)
      allow delete: if isAuthenticated() && 
        (resource.data.authorId == request.auth.uid ||
         resource.data.collectionOwnerId == request.auth.uid);
      
      // Comments subcollection
      match /comments/{commentId} {
        // Helper function to get parent post
        function getPost() {
          return get(/databases/$(database)/documents/posts/$(postId)).data;
        }
        
        // Helper function to check if user is post author
        function isPostAuthor() {
          return isAuthenticated() && getPost().authorId == request.auth.uid;
        }
        
        // Anyone authenticated can read comments
        allow read: if isAuthenticated();
        // Only comment authors can create/update/delete their comments
        allow create: if isAuthenticated() && request.resource.data.authorId == request.auth.uid;
        // Allow comment authors to delete their comments
        // Also allow post author to delete all comments on their post (for account deletion)
        allow update, delete: if isAuthenticated() && (
          request.resource.data.authorId == request.auth.uid ||
          resource.data.authorId == request.auth.uid ||
          isPostAuthor()
        );
      }
      
      // Stars subcollection (for post starring)
      match /stars/{userId} {
        // Anyone authenticated can read stars
        allow read: if isAuthenticated();
        // Users can create/delete their own star
        // Also allow post author to delete all stars on their post (for account deletion)
        allow create, delete: if isAuthenticated() && (
          request.auth.uid == userId ||
          get(/databases/$(database)/documents/posts/$(postId)).data.authorId == request.auth.uid
        );
      }
    }
    
    // Friend requests collection
    match /friend_requests/{requestId} {
      // Users can read their own incoming requests (where they are the recipient)
      allow read: if isAuthenticated() && (
        resource.data.toUid == request.auth.uid ||
        resource.data.fromUid == request.auth.uid
      );
      
      // Users can create friend requests (where they are the sender)
      allow create: if isAuthenticated() && 
        request.resource.data.fromUid == request.auth.uid;
      
      // Users can update requests where they are the recipient (accept/deny) or sender (cancel)
      allow update: if isAuthenticated() && (
        resource.data.toUid == request.auth.uid ||
        resource.data.fromUid == request.auth.uid
      );
      
      // Users can delete requests where they are the sender (cancel) or recipient (after deny)
      allow delete: if isAuthenticated() && (
        resource.data.fromUid == request.auth.uid ||
        resource.data.toUid == request.auth.uid
      );
    }
    
    // Chat rooms collection
    match /chat_rooms/{chatRoomId} {
      // Helper function to check if user is a participant in the chat room
      function isParticipant() {
        return isAuthenticated() && 
          request.auth.uid in resource.data.participants;
      }
      
      // Helper function to check if user is a participant when creating
      function isParticipantOnCreate() {
        return isAuthenticated() && 
          request.auth.uid in request.resource.data.participants;
      }
      
      // Users can read chat rooms where they are a participant
      allow read: if isParticipant();
      
      // Users can create chat rooms where they are a participant
      allow create: if isParticipantOnCreate();
      
      // Users can update chat rooms where they are a participant
      allow update: if isParticipant();
      
      // Users can delete chat rooms where they are a participant
      allow delete: if isParticipant();
      
      // Messages subcollection
      match /messages/{messageId} {
        // Helper function to get parent chat room
        function getChatRoom() {
          return get(/databases/$(database)/documents/chat_rooms/$(chatRoomId)).data;
        }
        
        // Helper function to check if user is a participant in the parent chat room
        function isChatParticipant() {
          return isAuthenticated() && 
            request.auth.uid in getChatRoom().participants;
        }
        
        // Helper function to check if user is the message sender
        function isMessageSender() {
          return isAuthenticated() && 
            resource.data.senderUid == request.auth.uid;
        }
        
        // Users can read messages if they are a participant in the chat room
        allow read: if isChatParticipant();
        
        // Users can create messages if they are a participant and are the sender
        allow create: if isAuthenticated() && 
          request.auth.uid in getChatRoom().participants &&
          request.resource.data.senderUid == request.auth.uid;
        
        // Users can update messages if they are the sender (for editing)
        // OR if they are a participant updating only the reactions field
        allow update: if isAuthenticated() && 
          request.auth.uid in getChatRoom().participants &&
          (
            // Allow sender to update any field (for editing)
            isMessageSender() ||
            // Allow any participant to update only the reactions field
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions'])
          );
        
        // Users can delete messages if they are a participant
        // (participants can "delete for me" by adding themselves to deletedFor array)
        allow delete: if isAuthenticated() && 
          request.auth.uid in getChatRoom().participants;
      }
    }
    
    // Notifications collection (top-level, not subcollection)
    match /notifications/{notificationId} {
      // Users can read notifications where they are the recipient
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      // Users can list/query notifications (for account deletion - will be filtered by delete rules)
      allow list: if isAuthenticated();
      // Anyone authenticated can create notifications
      allow create: if isAuthenticated();
      // Users can delete their own notifications or notifications they created (for account deletion)
      allow delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.actorId == request.auth.uid
      );
    }
    
    // Default deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
